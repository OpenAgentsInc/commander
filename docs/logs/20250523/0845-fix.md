# Critical Wallet Fix - 0845

## Problem Analysis
From telemetry logs, I can see:
1. Runtime is built with user's mnemonic: "deliver cr..."
2. Runtime is built AGAIN with test mnemonic: "test test ..."
3. The test mnemonic runtime is the one being used for balance queries
4. Balance shows 48 sats (from test wallet) instead of user's balance

## Root Cause
The runtime was ALWAYS building with a fallback to test mnemonic:
```typescript
const userMnemonic = globalWalletConfig.mnemonic || "test test test test test test test test test test test junk";
```

This means even after reinitialization, if there's any timing issue, it falls back to test wallet.

## Solution Implemented
1. **Remove ALL test mnemonic usage from production runtime**
   - When no wallet is initialized, use SparkServiceTestLive (mock) instead
   - Mock returns 0 balance when no wallet exists
   - NEVER use the hardcoded test mnemonic

2. **Updated runtime.ts**:
   ```typescript
   if (globalWalletConfig.mnemonic) {
     // Use real SparkService with user's mnemonic
     sparkLayer = SparkServiceLive.pipe(...);
   } else {
     // Use mock SparkService that returns 0 balance
     sparkLayer = SparkServiceTestLive.pipe(...);
   }
   ```

3. **Updated SparkServiceTestImpl**:
   - Detects "mock_no_wallet" mnemonic
   - Returns 0 balance instead of test balance
   - Properly handles the no-wallet state

4. **Security improvement**:
   - Removed mnemonic logging that exposed first 10 chars
   - Now only logs network information

## Result
- No more test wallet mnemonic in production code
- Users without wallet see 0 balance (not 48 sats)
- Users with wallet see their actual balance
- No security risk from shared test wallet